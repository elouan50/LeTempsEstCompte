<!DOCTYPE html>
<html lang="{{ lang }}">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metrics - LeTempsEstCompt√©</title>
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='favicon.svg') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        .tag-badge {
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(56, 189, 248, 0.1);
            border: 1px solid var(--accent);
            color: var(--accent);
            display: inline-block;
            margin: 0.2rem;
        }

        /* Toggle Switch Styles */
        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            top: 3px;
            background-color: var(--text-primary);
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        input:checked+.slider:before {
            transform: translateX(20px);
            background-color: #fff;
        }

        input:checked+.slider {
            background-color: var(--accent);
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
            cursor: pointer;
            user-select: none;
        }

        .chart-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .chart-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        /* Detail Popup (Fixed) */
        .detail-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(4px);
            z-index: 3000;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .detail-popup-overlay.active {
            display: flex;
            opacity: 1;
        }

        .detail-card {
            background: var(--card-bg);
            /* Opaque background */
            border: 1px solid var(--border);
            border-radius: 16px;
            width: 100%;
            max-width: 450px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            transform: translateY(20px);
            transition: transform 0.3s ease;
            overflow: hidden;
        }

        .detail-popup-overlay.active .detail-card {
            transform: translateY(0);
        }

        .detail-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .detail-title-group h3 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--text-primary);
        }

        .detail-subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .close-detail {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            line-height: 1;
            transition: color 0.2s;
        }

        .close-detail:hover {
            color: var(--text-primary);
        }

        .detail-body {
            padding: 1.5rem;
            overflow-y: auto;
            flex: 1;
        }

        .detail-section {
            margin-bottom: 1.5rem;
        }

        .detail-section h4 {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin: 0 0 0.75rem 0;
        }

        .task-list-detailed {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .task-item-detailed {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            background: rgba(255, 255, 255, 0.03);
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .task-detail-status {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .task-detail-completed {
            background: rgba(34, 197, 94, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .task-detail-pending {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
            border: 1px solid var(--danger);
        }

        .detail-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            background: rgba(255, 255, 255, 0.02);
        }

        /* Tag Tasks Popup (Keep for hover if needed) */
        .tag-tasks-popup {
            position: absolute;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.4), 0 8px 10px -6px rgba(0, 0, 0, 0.4);
            z-index: 2000;
            min-width: 250px;
            max-width: 320px;
            pointer-events: none;
            display: none;
            backdrop-filter: blur(8px);
            transition: opacity 0.2s ease;
        }

        .tag-tasks-popup h4 {
            margin: 0 0 0.75rem 0;
            font-size: 0.95rem;
            color: var(--accent);
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tag-tasks-popup ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .tag-tasks-popup li {
            font-size: 0.85rem;
            color: var(--text-primary);
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            line-height: 1.4;
        }

        .tag-tasks-popup .task-status {
            font-size: 0.8rem;
            font-weight: bold;
            flex-shrink: 0;
            margin-top: 2px;
        }

        /* Hierarchical Pill UI */
        .super-pill {
            display: flex;
            flex-direction: column;
            padding: 0.6rem 1rem;
            border-radius: 24px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            min-width: 140px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        .super-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .super-pill.expanded {
            border-color: var(--accent);
            background: rgba(var(--accent-rgb), 0.05);
        }

        .super-pill-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.75rem;
        }

        .supertag-name {
            font-size: 0.9rem;
            font-weight: 600;
            outline: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .supertag-name:focus {
            border-bottom-color: currentColor;
        }

        .subpill-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .subpill {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            white-space: nowrap;
        }
    </style>
    <script>
        const i18n = {{ t | tojson | safe }};
        const currentLang = "{{ lang }}";
        const SESSION_ID = null;
        const BIRTHDAY_MD = "{{ birthday_md if birthday_md else '' }}";

        const cookieLang = document.cookie.split('; ').find(row => row.startsWith('lang='))?.split('=')[1];
        if (cookieLang && cookieLang !== currentLang && !sessionStorage.getItem('reloaded_for_lang')) {
            console.warn("Language mismatch detected. Forcing hard reload to bypass bad cache...");
            sessionStorage.setItem('reloaded_for_lang', 'true');
            window.location.reload(true);
        } else {
            sessionStorage.removeItem('reloaded_for_lang');
        }
    </script>
    <meta name="theme-color" content="#0f172a">
</head>

<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
            <h1>{{ t['app_name'] }}</h1>
            <div style="display: flex; gap: 0.75rem; flex-wrap: wrap; justify-content: flex-end; align-items: center;">
                <div class="lang-switcher" style="display: flex; align-items: center;">
                    <a href="/profile" class="btn btn-secondary btn-sm"
                        style="padding: 0.5rem 0.75rem; display: flex; align-items: center; margin-right: 0.75rem;">
                        <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;">
                            <path
                                d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z" />
                        </svg>
                    </a>
                    <details class="action-details">
                        <summary class="btn btn-secondary btn-sm"
                            style="padding: 0.5rem 0.75rem; display: flex; align-items: center;">
                            <svg class="lang-icon" viewBox="0 0 24 24">
                                <path
                                    d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z" />
                            </svg>
                            {{ lang | upper }} <span style="font-size: 0.7rem; margin-left: 0.25rem;">‚ñº</span>
                        </summary>
                        <div class="action-menu-content">
                            <a href="/set_language/en"
                                style="text-decoration: none; color: inherit; padding: 0.5rem 0.75rem; display: flex; align-items: center; gap: 0.5rem;"><span>üá¨üáß</span>
                                English</a>
                            <a href="/set_language/de"
                                style="text-decoration: none; color: inherit; padding: 0.5rem 0.75rem; display: flex; align-items: center; gap: 0.5rem;"><span>üá©üá™</span>
                                Deutsch</a>
                            <a href="/set_language/fr"
                                style="text-decoration: none; color: inherit; padding: 0.5rem 0.75rem; display: flex; align-items: center; gap: 0.5rem;"><span>üá´üá∑</span>
                                Fran√ßais</a>
                        </div>
                    </details>
                </div>
                <a href="/reports" class="btn btn-secondary" style="display: inline-flex; align-items: center;">
                    <svg viewBox="0 0 24 24"
                        style="width: 18px; height: 18px; fill: currentColor; margin-right: 0.5rem;">
                        <path
                            d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z" />
                    </svg>
                    {{ t['reports'] }}
                </a>
                <a href="/new" class="btn">{{ t['start_new_day'] }}</a>
            </div>
        </div>

        <div class="card">
            <div
                style="display: flex; align-items: flex-end; justify-content: space-between; gap: 1rem; margin-bottom: 2rem;">
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <label class="toggle-container" style="margin-bottom: 0.5rem;">
                        <span>{{ t.get('show_focus_sessions', 'Focus sessions') }}</span>
                        <div class="switch">
                            <input type="checkbox" id="showFocusToggle" onchange="toggleFocusDisplay()">
                            <span class="slider"></span>
                        </div>
                    </label>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 1rem;">
                    <div class="chart-controls" id="viewControls">
                        <button class="btn btn-secondary btn-sm" data-view="day" onclick="switchView('day')">{{ t['day']
                            }}</button>
                        <button class="btn btn-secondary btn-sm" data-view="week" onclick="switchView('week')">{{
                            t['week'] }}</button>
                        <button class="btn btn-secondary btn-sm" data-view="month" onclick="switchView('month')">{{
                            t['month'] }}</button>
                        <button class="btn btn-secondary btn-sm" data-view="year" onclick="switchView('year')">{{
                            t['year'] }}</button>
                    </div>
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <button class="btn btn-secondary btn-sm" onclick="navigate(-1)">‚Üê</button>
                        <button class="btn btn-secondary btn-sm" onclick="goToToday()">{{ t['today'] }}</button>
                        <span id="periodLabel"
                            style="font-weight: 500; color: var(--text-primary); min-width: 180px; text-align: center;"></span>
                        <button class="btn btn-secondary btn-sm" onclick="navigate(1)">‚Üí</button>
                    </div>
                </div>
            </div>

            <div
                style="display: grid; grid-template-columns: minmax(0, 2fr) minmax(0, 1fr); gap: 2rem; margin-bottom: 3rem;">
                <!-- Main Daily Chart -->
                <div
                    style="height: 520px; display: flex; flex-direction: column; background: var(--bg-secondary); border-radius: 12px; padding: 1rem; border: 1px solid var(--border); min-width: 0;">
                    <h3
                        style="text-align: center; margin-bottom: 0.5rem; font-size: 0.9rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em;">
                        {{ t['productivity_timeline'] }}</h3>
                    <div style="flex: 1; min-height: 0;">
                        <canvas id="metricsChart"></canvas>
                    </div>
                </div>

                <!-- Circular Charts side container, stacked -->
                <div style="display: flex; flex-direction: column; gap: 20px; height: 520px;">
                    <!-- Time Breakdown -->
                    <div
                        style="height: 250px; display: flex; flex-direction: column; align-items: center; min-width: 0; background: var(--bg-secondary); border-radius: 12px; padding: 1rem; border: 1px solid var(--border);">
                        <h3
                            style="margin-bottom: 0.5rem; font-size: 0.9rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em;">
                            {{ t.get('time_breakdown', 'Time Breakdown') }}</h3>
                        <div
                            style="flex: 1; width: 100%; display: flex; align-items: center; justify-content: center; position: relative;">
                            <canvas id="tagChartTime"></canvas>
                            <div id="tagChartTimeEmpty"
                                style="display: none; text-align: center; color: var(--text-secondary);">
                                <svg viewBox="0 0 24 24"
                                    style="width: 24px; height: 24px; fill: currentColor; opacity: 0.3; margin-bottom: 0.3rem;">
                                    <path
                                        d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z" />
                                </svg>
                                <div style="font-size: 0.75rem;">{{ t.get('no_data_to_show', 'No data') }}</div>
                            </div>
                        </div>
                    </div>

                    <!-- Task Breakdown -->
                    <div
                        style="height: 250px; display: flex; flex-direction: column; align-items: center; min-width: 0; background: var(--bg-secondary); border-radius: 12px; padding: 1rem; border: 1px solid var(--border);">
                        <h3
                            style="margin-bottom: 0.5rem; font-size: 0.9rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em;">
                            {{ t.get('task_breakdown', 'Task Breakdown') }}</h3>
                        <div
                            style="flex: 1; width: 100%; display: flex; align-items: center; justify-content: center; position: relative;">
                            <canvas id="tagChartTasks"></canvas>
                            <div id="tagChartTasksEmpty"
                                style="display: none; text-align: center; color: var(--text-secondary);">
                                <svg viewBox="0 0 24 24"
                                    style="width: 24px; height: 24px; fill: currentColor; opacity: 0.3; margin-bottom: 0.3rem;">
                                    <path
                                        d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z" />
                                </svg>
                                <div style="font-size: 0.75rem;">{{ t.get('no_data_to_show', 'No data') }}</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="statsSummary"
                style="display: flex; gap: 2rem; align-items: center; margin-bottom: 2rem; padding-top: 1rem; border-top: 1px solid #334155;">
                <div id="totalHoursContainer">
                    <div style="color: var(--text-secondary); font-size: 0.9rem;">{{ t['total_hours'] }}</div>
                    <div id="totalHours" style="font-size: 1.5rem; font-weight: 600;">-- h</div>
                </div>
                <div id="tagSummary" class="tag-summary-scroll"
                    style="flex: 1; display: flex; gap: 0.75rem; flex-wrap: nowrap; justify-content: flex-start; align-items: center; overflow-x: auto; padding-bottom: 0.5rem; padding-top: 0.5rem; scroll-behavior: smooth; scrollbar-width: thin; scrollbar-color: var(--accent) transparent;">
                </div>
            </div>
        </div>

        <div class="card">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h2>{{ t['session_history'] }}</h2>
                <button onclick="openFilterModal()" class="btn btn-secondary btn-sm">
                    {{ t['filter_search'] }}
                </button>
            </div>
            <div class="session-history-scroll">
                <table class="metrics-table">
                    <thead>
                        <tr>
                            <th>{{ t['date'] }}</th>
                            <th>{{ t['goal'] }}</th>
                            <th>{{ t['start'] }}</th>
                            <th>{{ t['end'] }}</th>
                            <th>{{ t['pause'] }}</th>
                            <th>{{ t['tasks_completed'] }}</th>
                            <th>{{ t['status'] }}</th>
                            <th>{{ t['actions'] }}</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for session in sessions %}
                        <tr>
                            <td>{{ session.date.strftime('%Y-%m-%d') }}</td>
                            <td>{{ session.goal }}</td>
                            <td class="time-cell" data-type="start" data-session-id="{{ session.id }}"
                                data-date="{{ session.date.strftime('%Y-%m-%d') }}"
                                data-time="{{ session.start_time.isoformat() if session.start_time and session.status == 'work' else '' }}">
                            </td>
                            <td class="time-cell" data-type="end" data-session-id="{{ session.id }}"
                                data-date="{{ session.date.strftime('%Y-%m-%d') }}"
                                data-time="{{ session.end_time.isoformat() if session.end_time and session.status == 'work' else '' }}">
                            </td>
                            <td>
                                {% if session.status == 'sick' or session.status == 'vacation' %}
                                -
                                {% else %}
                                {% set total_pause_mins = namespace(value=0) %}
                                {% for pause in session.pauses %}
                                {% if pause.start_time and pause.end_time %}
                                {% set duration = pause.end_time - pause.start_time %}
                                {% set total_pause_mins.value = total_pause_mins.value +
                                (duration.total_seconds() / 60)
                                | int %}
                                {% endif %}
                                {% endfor %}
                                {% if total_pause_mins.value > 0 %}
                                {{ total_pause_mins.value }}min
                                {% else %}
                                -
                                {% endif %}
                                {% endif %}
                            </td>
                            <td>
                                {% set completed_tasks = session.tasks|selectattr('is_completed', 'equalto',
                                true)|list
                                %}
                                {% set total_tasks = session.tasks|length %}

                                {% if total_tasks > 0 %}
                                <details class="task-details">
                                    <summary>
                                        {{ completed_tasks|length }} / {{ total_tasks }}
                                        <span class="dropdown-icon">‚ñº</span>
                                    </summary>
                                    <ul class="completed-task-list">
                                        {% for task in session.tasks %}
                                        <li style="display: flex; align-items: center; gap: 0.5rem;">
                                            {% if task.is_completed %}
                                            <span style="color: var(--success); font-weight: bold;">‚úì</span>
                                            {% else %}
                                            <span style="color: var(--danger); font-weight: bold;">‚úó</span>
                                            {% endif %}
                                            <span style="flex: 1;">{{ task.description }}</span>
                                        </li>
                                        {% endfor %}
                                    </ul>
                                </details>
                                {% else %}
                                0 / 0
                                {% endif %}
                            </td>
                            <td>
                                {% if session.status == 'sick' %}
                                <span style="color: var(--accent);">{{ t['sick'] }}</span>
                                {% elif session.status == 'vacation' %}
                                <span style="color: var(--accent);">{{ t['vacation'] }}</span>
                                {% else %}
                                {% if session.end_time %}
                                <span style="color: var(--success);">{{ t['completed'] }}</span>
                                {% else %}
                                <span style="color: var(--accent);">{{ t['in_progress'] }}</span>
                                {% endif %}
                                {% endif %}
                            </td>
                            <td style="overflow: visible;">
                                <details class="action-details">
                                    <summary class="btn btn-secondary btn-sm" style="padding: 0.25rem 0.75rem;">
                                        &nbsp;&nbsp;<span style="font-size: 0.7rem;">‚ñº&nbsp;&nbsp;&nbsp;&nbsp;</span>
                                    </summary>
                                    <div class="action-menu-content">
                                        <button onclick="updateSession('{{ session.id }}')">{{ t['update']
                                            }}</button>
                                        <button onclick="deleteSession('{{ session.id }}')" class="text-danger">{{
                                            t['delete'] }}</button>
                                    </div>
                                </details>
                            </td>
                        </tr>
                        {% else %}
                        <tr>
                            <td colspan="8" style="text-align: center; padding: 2rem;">{{ t['no_sessions'] }}
                            </td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Filter Modal -->
    <div id="filterModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>{{ t['filter_sessions'] }}</h2>
                <button onclick="closeFilterModal()"
                    style="background:none; border:none; color:var(--text-secondary); cursor:pointer; font-size:1.5rem;">&times;</button>
            </div>

            <div class="filter-group">
                <label>{{ t['text_search'] }}</label>
                <input type="text" id="filterText" placeholder="{{ t['placeholder_search'] }}" class="input-field"
                    style="margin-bottom:0;">
            </div>

            <div class="filter-row">
                <div class="filter-group">
                    <label>{{ t['from_date'] }}</label>
                    <input type="date" id="filterDateStart" class="input-field" style="margin-bottom:0;">
                </div>
                <div class="filter-group">
                    <label>{{ t['to_date'] }}</label>
                    <input type="date" id="filterDateEnd" class="input-field" style="margin-bottom:0;">
                </div>
            </div>

            <div class="filter-row">
                <div class="filter-group">
                    <label>{{ t['started_before'] }}</label>
                    <input type="text" id="filterTimeStartBefore" class="input-field" placeholder="HH:MM"
                        inputmode="numeric" pattern="^([01]\d|2[0-3]):[0-5]\d$" style="margin-bottom:0;">
                </div>
                <div class="filter-group">
                    <label>{{ t['ended_after'] }}</label>
                    <input type="text" id="filterTimeEndAfter" class="input-field" placeholder="HH:MM"
                        inputmode="numeric" pattern="^([01]\d|2[0-3]):[0-5]\d$" style="margin-bottom:0;">
                </div>
            </div>

            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="resetFilters()">{{ t['reset'] }}</button>
                <div style="flex-grow: 1;"></div>
                <button class="btn btn-secondary" onclick="closeFilterModal()">{{ t['cancel'] }}</button>
                <button class="btn" onclick="applyFilters()">{{ t['apply'] }}</button>
            </div>
        </div>
    </div>

    <!-- Detail Popup -->
    <div id="detailPopup" class="detail-popup-overlay">
        <div class="detail-card">
            <div class="detail-header">
                <div class="detail-title-group">
                    <h3 id="detailTitle">Session Details</h3>
                    <div id="detailSubtitle" class="detail-subtitle">Thursday 24 Oct, 2024</div>
                </div>
                <button class="close-detail" onclick="closeDetailPopup()">&times;</button>
            </div>
            <div class="detail-body">
                <div class="detail-section">
                    <h4>{{ t.get('summary', 'Summary') }}</h4>
                    <div id="detailStatsSummary" style="display: flex; gap: 1.5rem; margin-top: 0.5rem;">
                        <!-- Stats go here -->
                    </div>
                </div>
                <div class="detail-section">
                    <h4>{{ t['tasks'] }}</h4>
                    <ul id="detailTasksList" class="task-list-detailed">
                        <!-- Tasks go here -->
                    </ul>
                </div>
            </div>
            <div class="detail-footer">
                <a id="detailLink" href="#" class="btn btn-secondary btn-sm">{{ t['open_dashboard'] }}</a>
            </div>
        </div>
    </div>

    <!-- Tag Tasks Small Popup (for Hover) -->
    <div id="tagTasksPopup" class="tag-tasks-popup">
        <h4 id="popupTagTitle"></h4>
        <ul id="popupTasksList"></ul>
    </div>

    <script>

        function updateSession(id) {
            window.location.href = `/dashboard/${id}?edit=true`;
        }

        async function updateSuperTagName(color, name) {
            const res = await fetch('/api/supertag/update_name', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ color: color, name: name })
            });
            if (!res.ok) alert("Failed to update supertag name");
        }

        async function deleteSession(id) {
            if (!confirm(i18n['confirm_delete'])) return;

            const res = await fetch('/api/session/delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: id })
            });

            if (res.ok) {
                window.location.reload();
            } else {
                alert(i18n['failed_delete']);
            }
        }

        async function updateTime(sessionId, type, timeStr) {
            // Find the date for this session from the row
            // We can find the Date cell in the same row, or pass it. 
            // Better: use the original full ISO string from data attribute to get the YYYY-MM-DD
            // Actually, we can just grab the date from the backend data if we had it, but here in DOM...

            // Let's use the row. The first cell is the date.
            // But getting the row is slightly messy.
            // EASIER: Store the full Date (YYYY-MM-DD) in a data attribute on the input or cell.

            const inputEl = event.target;
            const dateStr = inputEl.getAttribute('data-date'); // YYYY-MM-DD

            if (!dateStr || !timeStr) return;

            // Construct local DateTime string: "YYYY-MM-DDTHH:MM:00"
            const dateTimeStr = `${dateStr}T${timeStr}:00`;
            const dateObj = new Date(dateTimeStr); // Local date object
            const isoStr = dateObj.toISOString();

            const payload = { session_id: sessionId };
            if (type === 'start') payload.start_time = isoStr;
            if (type === 'end') payload.end_time = isoStr;

            const res = await fetch('/api/session/update_times', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (res.ok) {
                // Ideally refresh chart data without full reload, but reload ensures consistency
                // Let's settle for silent success or visual feedback?
                // Full reload might interrupt if user is editing multiple.
                // Let's re-fetch data for chart silently.
                initMetrics();
                // Visual feedback
                const originalColor = inputEl.style.color;
                inputEl.style.color = 'var(--success)';
                setTimeout(() => inputEl.style.color = originalColor, 1000);
            } else {
                alert(i18n['failed_update']);
            }
        }

        let chartInstance = null;
        let tagChartTimeInstance = null;
        let tagChartTasksInstance = null;
        let allData = [];
        let currentViewDate = new Date();
        let currentViewType = localStorage.getItem('metricsViewType') || 'week';
        let showFocusSessions = localStorage.getItem('showFocusSessions') === 'true';

        function toggleFocusDisplay() {
            showFocusSessions = document.getElementById('showFocusToggle').checked;
            localStorage.setItem('showFocusSessions', showFocusSessions);
            renderCurrentView();
        }

        function getLocalHour(isoString) {
            if (!isoString) return null;
            const date = new Date(isoString);
            return date.getHours() + date.getMinutes() / 60;
        }

        function formatHour(val) {
            if (val === null) return '';
            const h = Math.floor(val);
            const m = Math.round((val - h) * 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
        }

        async function initMetrics() {
            const res = await fetch('/api/metrics/data?_=' + Date.now());
            allData = await res.json();

            // Initialize toggle state
            const toggle = document.getElementById('showFocusToggle');
            if (toggle) {
                toggle.checked = showFocusSessions;
            }

            switchView(currentViewType);
        }

        // Helper: Get Monday of the current week
        function getStartOfWeek(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // adjust when day is sunday
            return new Date(d.setDate(diff));
        }

        function switchView(type) {
            currentViewType = type;
            localStorage.setItem('metricsViewType', type);

            // Highlight active button
            const controls = document.getElementById('viewControls');
            if (controls) {
                controls.querySelectorAll('button').forEach(btn => {
                    if (btn.getAttribute('data-view') === type) {
                        btn.style.backgroundColor = 'var(--accent)';
                        btn.style.borderColor = 'var(--accent)';
                        btn.style.color = '#fff';
                    } else {
                        btn.style.backgroundColor = '';
                        btn.style.borderColor = '';
                        btn.style.color = '';
                    }
                });
            }

            currentViewDate = currentViewDate || new Date();
            // Removed: currentViewDate = new Date(); (Preserve date for drill-down)
            renderCurrentView();
        }

        function getWeekNumber(d) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return weekNo;
        }

        function goToToday() {
            currentViewDate = new Date();
            renderCurrentView();
        }

        function navigate(offset) {
            const d = new Date(currentViewDate);
            if (currentViewType === 'day') {
                d.setDate(d.getDate() + offset);
            } else if (currentViewType === 'week') {
                d.setDate(d.getDate() + (offset * 7));
            } else if (currentViewType === 'month') {
                d.setMonth(d.getMonth() + offset);
            } else if (currentViewType === 'year') {
                d.setFullYear(d.getFullYear() + offset);
            }
            currentViewDate = d;
            renderCurrentView();
        }

        function updateLabel(start, end, singleLabel = null) {
            const labelEl = document.getElementById('periodLabel');
            const opts = { year: 'numeric', month: 'short', day: 'numeric' };
            if (singleLabel) {
                labelEl.innerText = singleLabel;
            } else {
                labelEl.innerText = `${start.toLocaleDateString(currentLang, opts)} - ${end.toLocaleDateString(currentLang, opts)}`;
            }
        }

        // Helper to get total pause hours from pauses array
        function getTotalPauseHours(pauses) {
            if (!pauses || pauses.length === 0) return 0;
            let total = 0;
            pauses.forEach(p => {
                const ps = getLocalHour(p.start_time);
                const pe = getLocalHour(p.end_time);
                if (ps !== null && pe !== null) {
                    total += (pe - ps);
                }
            });
            return total;
        }

        function getWorkSegments(entry) {
            if (!entry) return [];

            if (entry.status === 'sick' || entry.status === 'vacation') {
                return [[9, 18]];
            }

            if (!entry.start_time) return [];
            const s = getLocalHour(entry.start_time);
            let e = getLocalHour(entry.end_time);

            if (e === null) {
                const now = new Date();
                e = now.getHours() + (now.getMinutes() / 60);
            }

            let segments = [];
            let currentStart = s;

            // Filter and sort pauses that fall within the work day
            const pauses = (entry.pauses || [])
                .map(p => ({
                    s: getLocalHour(p.start_time),
                    e: getLocalHour(p.end_time)
                }))
                .filter(p => p.s !== null && p.s >= s && p.s <= e)
                .sort((a, b) => a.s - b.s);

            pauses.forEach(p => {
                if (p.s > currentStart) {
                    segments.push([currentStart, p.s]);
                }
                currentStart = (p.e !== null && p.e <= e) ? p.e : (e + 1);
            });

            if (e > currentStart) {
                segments.push([currentStart, e]);
            }
            return segments;
        }

        function renderCurrentView() {
            let chartLabels = [];
            let chartDatasetsData = [];
            let dayToSegments = []; // Temp storage for transposition
            let chartIds = [];
            let relevantData = [];
            let alignedSessions = [];
            let todayIndex = null;
            const now = new Date();
            const todayY = now.getFullYear();
            const todayM = now.getMonth();
            const todayD = now.getDate();

            // Helper to Average entries for year view
            const computeAverage = (entries) => {
                if (!entries || entries.length === 0) return null;
                let count = 0;
                let sumStart = 0, sumEnd = 0;

                entries.forEach(e => {
                    const s = getLocalHour(e.start_time);
                    const end = getLocalHour(e.end_time);

                    if (s !== null && end !== null) {
                        sumStart += s;
                        sumEnd += end;
                        count++;
                    }
                });

                if (count === 0) return null;
                return {
                    start: sumStart / count,
                    end: sumEnd / count
                };
            };

            if (currentViewType === 'day') {
                const dateStr = currentViewDate.toISOString().split('T')[0];
                const dayName = currentViewDate.toLocaleDateString(currentLang, { weekday: 'long' });
                updateLabel(null, null, `${dayName} ${currentViewDate.getDate()} ${currentViewDate.toLocaleDateString(currentLang, { month: 'short', year: 'numeric' })}`);

                if (currentViewDate.getFullYear() === todayY && currentViewDate.getMonth() === todayM && currentViewDate.getDate() === todayD) {
                    todayIndex = 0;
                }

                chartLabels.push(`${dayName} ${currentViewDate.getDate()}`);
                const entry = allData.find(x => x.date.startsWith(dateStr));
                if (entry) {
                    relevantData.push(entry);
                    alignedSessions.push(entry);
                    chartIds.push(entry.id);
                    dayToSegments.push(getWorkSegments(entry));
                } else {
                    alignedSessions.push(null);
                    chartIds.push(null);
                    dayToSegments.push([]);
                }

            } else if (currentViewType === 'week') {
                const startOfWeek = getStartOfWeek(currentViewDate);
                const endOfWeek = new Date(startOfWeek);
                endOfWeek.setDate(endOfWeek.getDate() + 6);

                updateLabel(startOfWeek, endOfWeek);

                for (let i = 0; i < 7; i++) {
                    const d = new Date(startOfWeek);
                    d.setDate(startOfWeek.getDate() + i);
                    const dateStr = d.toISOString().split('T')[0];
                    const dayName = d.toLocaleDateString(currentLang, { weekday: 'short' });

                    if (d.getFullYear() === todayY && d.getMonth() === todayM && d.getDate() === todayD) {
                        todayIndex = i;
                    }

                    chartLabels.push(`${dayName} ${d.getDate()}`);

                    // Find data for this specific day
                    const entry = allData.find(x => x.date.startsWith(dateStr));

                    if (entry) {
                        relevantData.push(entry);
                        alignedSessions.push(entry);
                        chartIds.push(entry.id);
                        dayToSegments.push(getWorkSegments(entry));
                    } else {
                        alignedSessions.push(null);
                        chartIds.push(null);
                        dayToSegments.push([]);
                    }
                }

            } else if (currentViewType === 'month') {
                const year = currentViewDate.getFullYear();
                const month = currentViewDate.getMonth();
                const daysInMonth = new Date(year, month + 1, 0).getDate();

                // Label: month name + year
                const monthName = currentViewDate.toLocaleDateString(currentLang, { month: 'long', year: 'numeric' });
                updateLabel(null, null, monthName);

                const monthEntries = allData.filter(x => {
                    const d = new Date(x.date);
                    return d.getFullYear() === year && d.getMonth() === month;
                });
                relevantData = monthEntries; // For stats

                for (let day = 1; day <= daysInMonth; day++) {
                    const dateObj = new Date(year, month, day);
                    const y = dateObj.getFullYear();
                    const m = String(dateObj.getMonth() + 1).padStart(2, '0');
                    const d = String(dateObj.getDate()).padStart(2, '0');
                    const dateKey = `${y}-${m}-${d}`;

                    if (year === todayY && month === todayM && day === todayD) {
                        todayIndex = day - 1;
                    }

                    chartLabels.push(day.toString());

                    const entry = monthEntries.find(x => x.date.startsWith(dateKey));

                    if (entry) {
                        alignedSessions.push(entry);
                        chartIds.push(entry.id);
                        dayToSegments.push(getWorkSegments(entry));
                    } else {
                        alignedSessions.push(null);
                        chartIds.push(null);
                        dayToSegments.push([]);
                    }
                }

            } else if (currentViewType === 'year') {
                const year = currentViewDate.getFullYear();
                updateLabel(null, null, year.toString());

                const monthsFull = i18n['full_months'];

                const yearEntries = allData.filter(x => {
                    const d = new Date(x.date);
                    return d.getFullYear() === year;
                });
                relevantData = yearEntries;

                for (let idx = 0; idx < 12; idx++) {
                    const mName = monthsFull[idx];
                    chartLabels.push(mName);
                    chartIds.push(null); // No specific ID for month aggregate
                    alignedSessions.push(null);

                    if (year === todayY && idx === todayM) {
                        todayIndex = idx;
                    }

                    const mEntries = yearEntries.filter(x => new Date(x.date).getMonth() === idx);
                    const avg = computeAverage(mEntries);

                    if (avg) {
                        dayToSegments.push([[avg.start, avg.end]]);
                    } else {
                        dayToSegments.push([]);
                    }
                }
            }

            // Transpose dayToSegments (Array of segment arrays) into chartDatasetsData (Array of daily values per segment index)
            const maxSegs = Math.max(1, ...dayToSegments.map(segs => segs.length));
            for (let i = 0; i < maxSegs; i++) {
                chartDatasetsData.push(dayToSegments.map(segs => segs[i] || null));
            }

            // Extract status for each day to use for coloring
            const dayStatuses = chartLabels.map((_, i) => {
                const dateStr = currentViewType === 'week' ?
                    new Date(getStartOfWeek(currentViewDate).getTime() + i * 86400000).toISOString().split('T')[0] :
                    (currentViewType === 'month' ?
                        `${currentViewDate.getFullYear()}-${String(currentViewDate.getMonth() + 1).padStart(2, '0')}-${String(i + 1).padStart(2, '0')}` :
                        null);

                if (currentViewType === 'year') return 'work'; // Month averages are always 'work' color

                const entry = dateStr ? allData.find(x => x.date.startsWith(dateStr)) : null;
                return entry ? entry.status : 'work';
            });

            renderChart(chartLabels, chartDatasetsData, chartIds, todayIndex, dayStatuses, alignedSessions);
            computeStats(relevantData);
        }



        function computeStats(data) {
            let totalWork = 0; // Hours

            const now = new Date();
            const todayY = now.getFullYear();
            const todayM = now.getMonth();
            const todayD = now.getDate();

            data.forEach(d => {
                const start = getLocalHour(d.start_time);
                let end = getLocalHour(d.end_time);

                // If in progress and it's today, use current time for stats
                if (!end && start) {
                    const sessionDate = new Date(d.date);
                    if (sessionDate.getFullYear() === todayY &&
                        sessionDate.getMonth() === todayM &&
                        sessionDate.getDate() === todayD) {
                        end = now.getHours() + (now.getMinutes() / 60);
                    }
                }

                const pauseHours = getTotalPauseHours(d.pauses);

                // Calculate worked hours for this entry
                if (start && end) {
                    let work = end - start - pauseHours;
                    if (work > 0) totalWork += work;
                }
            });

            // Format Total Hours
            const h = Math.floor(totalWork);
            const m = Math.round((totalWork - h) * 60);
            document.getElementById('totalHours').innerText = `${h}h ${m.toString().padStart(2, '0')}min`;

            // Render tag breakdown
            renderTagBreakdown(data);
        }


        function renderTagBreakdown(data) {
            // Aggregate focus time and task counts by tag
            const tagTimeData = {}; // tag -> total minutes
            const tagTaskData = {}; // tag -> {completed: count, total: count}
            const tagColors = {};

            console.log('Tag breakdown - input data:', data);

            // Process focus sessions for time data
            let totalPeriodFocusMinutes = 0;
            let totalPeriodWorkedMinutes = 0;

            const now = new Date();
            const todayY = now.getFullYear();
            const todayM = now.getMonth();
            const todayD = now.getDate();

            data.forEach(session => {
                // Calculate worked minutes for this session
                const start = getLocalHour(session.start_time);
                let end = getLocalHour(session.end_time);
                if (!end && start) {
                    const sessionDate = new Date(session.date);
                    if (sessionDate.getFullYear() === todayY && sessionDate.getMonth() === todayM && sessionDate.getDate() === todayD) {
                        end = now.getHours() + (now.getMinutes() / 60);
                    }
                }
                const pauseHours = getTotalPauseHours(session.pauses);
                if (start && end) {
                    const workHours = Math.max(end - start - pauseHours, 0);
                    totalPeriodWorkedMinutes += workHours * 60;
                }

                if (session.focus_sessions) {
                    session.focus_sessions.forEach(fs => {
                        const tags = (fs.tags && fs.tags.length > 0) ? fs.tags : [i18n['untagged']];
                        const durationPerTag = fs.duration / tags.length;
                        totalPeriodFocusMinutes += fs.duration;
                        tags.forEach(tag => {
                            if (!tagTimeData[tag]) {
                                tagTimeData[tag] = 0;
                            }
                            tagTimeData[tag] += durationPerTag;
                        });
                    });
                }

                // Process tasks for task count data
                if (session.tasks) {
                    session.tasks.forEach(task => {
                        const tags = (task.tags && task.tags.length > 0) ? task.tags : [i18n['untagged']];
                        const countPerTag = 1;
                        tags.forEach(tagName => {
                            if (!tagTaskData[tagName]) {
                                tagTaskData[tagName] = { completed: 0, total: 0, tasks: [] };
                            }
                            tagTaskData[tagName].total += countPerTag;
                            if (task.is_completed) {
                                tagTaskData[tagName].completed += countPerTag;
                            }
                            // Add task to tag's task list (avoiding exact duplicates if needed, but here simple push is fine)
                            tagTaskData[tagName].tasks.push({
                                description: task.description,
                                is_completed: task.is_completed
                            });
                        });
                    });
                }
            });

            // Add the difference (Work - Focus) to Untagged time
            const untaggedTime = Math.max(totalPeriodWorkedMinutes - totalPeriodFocusMinutes, 0);
            if (untaggedTime > 0) {
                const untaggedKey = i18n['untagged'];
                if (!tagTimeData[untaggedKey]) tagTimeData[untaggedKey] = 0;
                tagTimeData[untaggedKey] += untaggedTime;
            }

            console.log('Tag time data:', tagTimeData);
            console.log('Tag task data:', tagTaskData);

            // Fetch tag colors AND supertags from the backend
            Promise.all([
                fetch('/api/tags').then(res => res.json()),
                fetch('/api/supertags').then(res => res.json())
            ])
                .then(([tags, supertags]) => {
                    tags.forEach(tag => {
                        tagColors[tag.name] = tag.color;
                    });
                    tagColors[i18n['untagged']] = '#94a3b8'; // Grey for Untagged

                    const supertagMap = {};
                    supertags.forEach(st => {
                        supertagMap[st.color] = st.name;
                    });

                    // Group results by color for the carousel AND charts
                    const colorGroups = {};
                    const allTagsSet = new Set([...Object.keys(tagTimeData), ...Object.keys(tagTaskData)]);

                    allTagsSet.forEach(tag => {
                        const color = tagColors[tag] || '#38bdf8';
                        if (!colorGroups[color]) {
                            colorGroups[color] = {
                                color: color,
                                name: supertagMap[color] || color,
                                timeMins: 0,
                                completed: 0,
                                total: 0,
                                subtags: []
                            };
                        }
                        const timeMins = tagTimeData[tag] || 0;
                        const taskData = tagTaskData[tag] || { completed: 0, total: 0, tasks: [] };

                        colorGroups[color].timeMins += timeMins;
                        colorGroups[color].completed += taskData.completed;
                        colorGroups[color].total += taskData.total;
                        colorGroups[color].subtags.push({
                            tag,
                            timeMins,
                            taskData
                        });
                    });

                    // Sort groups for Charts
                    const sortedTimeGroups = Object.values(colorGroups)
                        .filter(g => g.timeMins > 0)
                        .sort((a, b) => b.timeMins - a.timeMins);

                    const timeLabels = sortedTimeGroups.map(g => g.name);
                    const timeValues = sortedTimeGroups.map(g => g.timeMins / 60);
                    const timeColors = sortedTimeGroups.map(g => g.color);
                    const totalTimeMins = sortedTimeGroups.reduce((sum, g) => sum + g.timeMins, 0);

                    const sortedTaskGroups = Object.values(colorGroups)
                        .filter(g => g.total > 0)
                        .sort((a, b) => b.total - a.total);

                    const taskLabels = sortedTaskGroups.map(g => g.name);
                    const taskValues = sortedTaskGroups.map(g => g.total);
                    const taskColors = sortedTaskGroups.map(g => g.color);
                    const totalTasks = sortedTaskGroups.reduce((sum, g) => sum + g.total, 0);

                    // Create a lookup map for task tooltips by Supertag Name
                    const supertagTaskData = {};
                    sortedTaskGroups.forEach(g => {
                        supertagTaskData[g.name] = { completed: g.completed, total: g.total };
                    });

                    // Render Charts with Supertag Data
                    renderCharts(timeLabels, timeValues, timeColors, totalTimeMins, taskLabels, taskValues, taskColors, totalTasks, supertagTaskData, colorGroups);

                    // Render tag summary badges (grouped by color)
                    const tagSummary = document.getElementById('tagSummary');
                    tagSummary.innerHTML = '';

                    const sortedGroups = Object.values(colorGroups).sort((a, b) => b.timeMins - a.timeMins);

                    sortedGroups.forEach((group, index) => {
                        const hours = Math.floor(group.timeMins / 60);
                        const minutes = Math.round(group.timeMins % 60);
                        const completionRate = group.total > 0 ? (group.completed / group.total * 100) : 0;
                        const color = group.color;

                        const pill = document.createElement('div');
                        pill.className = 'super-pill';
                        pill.style.borderColor = `${color}40`;
                        pill.style.backgroundColor = `${color}08`;

                        pill.onclick = (e) => {
                            if (e.target.classList.contains('supertag-name')) return;

                            // Show detailed fixed popup
                            showSupertagDetails(group);
                        };

                        // Add hover behavior
                        pill.onmouseenter = (e) => {
                            const tasks = [];
                            group.subtags.forEach(st => {
                                if (st.taskData && st.taskData.tasks) {
                                    tasks.push(...st.taskData.tasks);
                                }
                            });
                            showTagTasksPopup(group.name, tasks, e);
                        };
                        pill.onmousemove = (e) => updateTagTasksPopupPosition(e);
                        pill.onmouseleave = () => hideTagTasksPopup();

                        pill.innerHTML = `
                            <div class="super-pill-header">
                                <div style="display: flex; flex-direction: column; gap: 0.1rem; flex: 1; min-width: 0;">
                                    <div class="supertag-name" contenteditable="true" 
                                         style="color: ${color};" 
                                         onblur="updateSuperTagName('${color}', this.innerText)"
                                         onclick="event.stopPropagation()"
                                         title="Click to edit Supertag name">${group.name}</div>
                                    <div style="font-size: 0.7rem; color: var(--text-secondary);">${hours}h ${minutes}m</div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-size: 0.75rem; font-weight: 600; color: ${color};">${Math.round(completionRate)}%</div>
                                    <div style="font-size: 0.65rem; color: var(--text-secondary);">${Math.round(group.completed * 10) / 10}/${Math.round(group.total * 10) / 10}</div>
                                </div>
                            </div>
                            <div style="width: 100%; height: 2px; background: rgba(255,255,255,0.05); border-radius: 1px; overflow: hidden; margin-top: 0.5rem;">
                                <div style="width: ${completionRate}%; height: 100%; background: ${color}; transition: width 0.3s ease;"></div>
                            </div>
                        `;

                        tagSummary.appendChild(pill);
                    });
                })
                .catch(err => console.error('Failed to load tags:', err));
        }

        // Helper to separate chart rendering from data grouping
        function renderCharts(timeLabels, timeValues, timeColors, totalTimeMins, taskLabels, taskValues, taskColors, totalTasks, tagTaskData, colorGroups) {
            // Render time-based doughnut chart
            const ctxTime = document.getElementById('tagChartTime').getContext('2d');
            const canvasTime = document.getElementById('tagChartTime');
            const emptyStateTime = document.getElementById('tagChartTimeEmpty');

            if (tagChartTimeInstance) tagChartTimeInstance.destroy();

            if (timeLabels.length > 0) {
                canvasTime.style.display = 'block';
                emptyStateTime.style.display = 'none';
                tagChartTimeInstance = new Chart(ctxTime, {
                    type: 'doughnut',
                    data: {
                        labels: timeLabels,
                        datasets: [{
                            data: timeValues,
                            backgroundColor: timeColors,
                            borderWidth: 2,
                            borderColor: '#1e293b'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        onClick: (e, elements) => {
                            if (elements && elements.length > 0) {
                                const index = elements[0].index;
                                const supertagName = timeLabels[index];
                                const group = Object.values(colorGroups).find(g => g.name === supertagName);
                                if (group) showSupertagDetails(group);
                            }
                        },
                        onHover: (event, elements) => {
                            event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        const hours = Math.floor(context.parsed);
                                        const mins = Math.round((context.parsed - hours) * 60);
                                        const percentage = totalTimeMins > 0 ? ((context.parsed * 60 / totalTimeMins) * 100).toFixed(1) : 0;
                                        return `${context.label}: ${hours}h ${mins}min (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    },
                    plugins: [{
                        id: 'datalabels',
                        afterDatasetsDraw: function (chart) {
                            const ctx = chart.ctx;
                            chart.data.datasets.forEach((dataset, i) => {
                                const meta = chart.getDatasetMeta(i);
                                meta.data.forEach((element, index) => {
                                    const data = dataset.data[index];
                                    const percentage = totalTimeMins > 0 ? ((data * 60 / totalTimeMins) * 100).toFixed(1) : 0;
                                    if (percentage > 5) {
                                        const position = element.tooltipPosition();
                                        ctx.font = 'bold 12px Inter';
                                        ctx.fillStyle = '#fff';
                                        ctx.textAlign = 'center';
                                        ctx.fillText(percentage + '%', position.x, position.y);
                                    }
                                });
                            });
                        }
                    }]
                });
            } else {
                canvasTime.style.display = 'none';
                emptyStateTime.style.display = 'flex';
            }

            // Render task-based doughnut chart
            const ctxTasks = document.getElementById('tagChartTasks').getContext('2d');
            const canvasTasks = document.getElementById('tagChartTasks');
            const emptyStateTasks = document.getElementById('tagChartTasksEmpty');

            if (tagChartTasksInstance) tagChartTasksInstance.destroy();

            if (taskLabels.length > 0) {
                canvasTasks.style.display = 'block';
                emptyStateTasks.style.display = 'none';
                tagChartTasksInstance = new Chart(ctxTasks, {
                    type: 'doughnut',
                    data: {
                        labels: taskLabels,
                        datasets: [{
                            data: taskValues,
                            backgroundColor: taskColors,
                            borderWidth: 2,
                            borderColor: '#1e293b'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        onClick: (e, elements) => {
                            if (elements && elements.length > 0) {
                                const index = elements[0].index;
                                const supertagName = taskLabels[index];
                                const group = Object.values(colorGroups).find(g => g.name === supertagName);
                                if (group) showSupertagDetails(group);
                            }
                        },
                        onHover: (event, elements) => {
                            event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        const supertagName = context.label;
                                        const groupData = tagTaskData[supertagName]; // actually supertagTaskData
                                        const percentage = totalTasks > 0 ? ((context.parsed / totalTasks) * 100).toFixed(1) : 0;
                                        if (groupData) {
                                            return `${supertagName}: ${groupData.completed}/${context.parsed} tasks (${percentage}%)`;
                                        }
                                        return `${supertagName}: ${context.parsed} tasks (${percentage}%)`;
                                    }
                                }
                            }
                        },
                        cutout: '70%'
                    }
                });
            } else {
                canvasTasks.style.display = 'none';
                emptyStateTasks.style.display = 'flex';
            }
        }

        function renderChart(labels, datasetsData, sessionIds, todayIndex, dayStatuses, sessionData) {
            const ctx = document.getElementById('metricsChart').getContext('2d');

            if (chartInstance) {
                chartInstance.destroy();
            }

            const colors = {
                'work': '#38bdf8',
                'vacation': '#fb923c', // Orange
                'sick': '#a78bfa'     // Violet
            };

            // Fetch tags for colors before rendering
            fetch('/api/tags')
                .then(res => res.json())
                .then(tags => {
                    const tagColors = {};
                    tags.forEach(t => tagColors[t.name] = t.color);
                    tagColors[i18n['untagged']] = '#94a3b8';

                    function createHashedPattern(colors) {
                        if (!colors || colors.length === 0) return '#94a3b8';
                        if (colors.length === 1) return colors[0];

                        const stripeCount = colors.length;
                        const stripeSize = 10;
                        const size = stripeSize * stripeCount * 2;
                        const canvas = document.createElement('canvas');
                        canvas.width = size;
                        canvas.height = size;
                        const tctx = canvas.getContext('2d');

                        // Create equal diagonal stripes
                        for (let i = -stripeCount * 2; i < stripeCount * 2; i++) {
                            tctx.fillStyle = colors[Math.abs(i) % stripeCount];
                            tctx.beginPath();
                            tctx.moveTo(i * stripeSize, 0);
                            tctx.lineTo((i + 1) * stripeSize, 0);
                            tctx.lineTo((i + 1) * stripeSize + size, size);
                            tctx.lineTo(i * stripeSize + size, size);
                            tctx.closePath();
                            tctx.fill();
                        }
                        return tctx.createPattern(canvas, 'repeat');
                    }

                    // Create base datasets
                    const datasets = datasetsData.map((data, idx) => ({
                        label: i18n['working_time'],
                        data: data,
                        backgroundColor: showFocusSessions ?
                            dayStatuses.map(s => (s === 'work' || !s) ? 'rgba(148, 163, 184, 0.3)' : (colors[s] || colors['work'])) :
                            (dayStatuses ? dayStatuses.map(s => colors[s] || colors['work']) : '#38bdf8'),
                        borderRadius: 4,
                        borderSkipped: false,
                        grouped: !showFocusSessions,
                        order: showFocusSessions ? 2 : 1,
                        borderWidth: (context) => {
                            const i = context.dataIndex;
                            if (sessionData && sessionData[i] && BIRTHDAY_MD) {
                                const d = sessionData[i].date; // ISO string 
                                if (d && d.substring(5, 10) === BIRTHDAY_MD) return 2;
                            }
                            return 0;
                        },
                        borderColor: (context) => {
                            const i = context.dataIndex;
                            if (sessionData && sessionData[i] && BIRTHDAY_MD) {
                                const d = sessionData[i].date;
                                if (d && d.substring(5, 10) === BIRTHDAY_MD) return '#F59E0B'; // Gold/Amber
                            }
                            return 'transparent';
                        }
                    }));

                    // Add Focus Sessions dataset if enabled
                    if (showFocusSessions && sessionData) {
                        const focusData = [];
                        const focusBackgroundColors = [];

                        // Align focus data with chart labels
                        sessionData.forEach((session, i) => {
                            if (session && session.focus_sessions) {
                                session.focus_sessions.forEach(fs => {
                                    const fsTags = (fs.tags && fs.tags.length > 0) ? fs.tags : [i18n['untagged']];
                                    let bg;

                                    if (fsTags.length > 1) {
                                        const c = fsTags.map(t => tagColors[t] || '#38bdf8');
                                        bg = createHashedPattern(c);
                                    } else {
                                        bg = tagColors[fsTags[0]] || '#38bdf8';
                                    }

                                    focusData.push({
                                        x: labels[i], // Match x-axis label
                                        y: [fs.start_hour, fs.end_hour],
                                        task_id: fs.task_id,
                                        task_name: fs.task_name,
                                        tags: fsTags,
                                        id: fs.id
                                    });
                                    focusBackgroundColors.push(bg);
                                });
                            }
                        });

                        if (focusData.length > 0) {
                            datasets.push({
                                label: i18n['focus'],
                                data: focusData,
                                backgroundColor: focusBackgroundColors,
                                borderRadius: 4,
                                borderSkipped: false,
                                type: 'bar',
                                grouped: false, // Ensure overlap
                                order: 0
                            });
                        }
                    }

                    chartInstance = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'x',
                            onClick: (e, elements) => {
                                if (elements && elements.length > 0) {
                                    const index = elements[0].index;

                                    // Year View: Click to drill down to Month
                                    if (currentViewType === 'year') {
                                        const monthIndex = index;
                                        const year = currentViewDate.getFullYear();
                                        currentViewDate = new Date(year, monthIndex, 1);
                                        switchView('month');
                                        return;
                                    }

                                    // Normal session click logic
                                    const datasetIndex = elements[0].datasetIndex;
                                    const dataset = datasets[datasetIndex];

                                    // Check if focus session
                                    if (dataset.label === i18n['focus']) {
                                        // elements[0].element.$context.raw is the actual data object clicked
                                        const raw = elements[0].element.$context.raw;
                                        if (raw && raw.task_id) {
                                            window.location.href = `/focus/task/${raw.task_id}`;
                                            return;
                                        }
                                    }

                                    const id = sessionIds[index];
                                    if (id) {
                                        const session = sessionData[index];
                                        if (session) {
                                            showSessionDetails(session);
                                        } else {
                                            window.location.href = `/dashboard/${id}?edit=true`;
                                        }
                                    }
                                } else {
                                    // Week Bar Click (Month View)
                                    if (currentViewType === 'month' && chartInstance.weekZones) {
                                        const { x, y } = e;
                                        const zone = chartInstance.weekZones.find(z =>
                                            x >= z.x && x <= z.x + z.w && y >= z.y && y <= z.y + z.h
                                        );

                                        if (zone) {
                                            const year = currentViewDate.getFullYear();
                                            const month = currentViewDate.getMonth();
                                            currentViewDate = new Date(year, month, zone.startDay);
                                            switchView('week');
                                        }
                                    }
                                }
                            },
                            onHover: (event, chartElement) => {
                                const target = event.native.target;
                                let tooltipEl = document.getElementById('week-chart-tooltip');
                                if (!tooltipEl) {
                                    tooltipEl = document.createElement('div');
                                    tooltipEl.id = 'week-chart-tooltip';
                                    Object.assign(tooltipEl.style, {
                                        position: 'fixed',
                                        background: 'rgba(30, 41, 59, 0.95)',
                                        color: '#f8fafc',
                                        borderRadius: '4px',
                                        padding: '6px 12px',
                                        fontFamily: 'Inter, sans-serif',
                                        fontSize: '12px',
                                        pointerEvents: 'none',
                                        zIndex: '9999',
                                        display: 'none',
                                        transform: 'translate(-50%, -120%)',
                                        boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.2)'
                                    });
                                    document.body.appendChild(tooltipEl);
                                }
                                tooltipEl.style.display = 'none';

                                if (chartElement.length > 0) {
                                    target.style.cursor = 'pointer';
                                    return;
                                }

                                if (currentViewType === 'month' && chartInstance.weekZones) {
                                    const { x, y } = event;
                                    const zone = chartInstance.weekZones.find(z =>
                                        x >= z.x && x <= z.x + z.w && y >= z.y && y <= z.y + z.h
                                    );
                                    if (zone) {
                                        target.style.cursor = 'pointer';
                                        tooltipEl.innerHTML = `<strong>Week ${zone.week}</strong>`;
                                        tooltipEl.style.display = 'block';
                                        tooltipEl.style.left = event.native.clientX + 'px';
                                        tooltipEl.style.top = event.native.clientY + 'px';
                                        return;
                                    }
                                }
                                target.style.cursor = 'default';
                            },
                            scales: {
                                y: {
                                    stacked: false,
                                    min: 7, max: 20,
                                    grid: { color: '#334155' },
                                    ticks: { color: '#94a3b8', stepSize: 1, callback: val => val + ':00' }
                                },
                                x: {
                                    stacked: !showFocusSessions,
                                    grid: { display: false },
                                    ticks: { color: '#94a3b8' }
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: function (context) {
                                            const raw = context.raw;
                                            if (raw.task_name) {
                                                const tagsStr = (raw.tags && raw.tags.length > 0) ? ` [${raw.tags.join(', ')}]` : '';
                                                return [`${raw.task_name}${tagsStr}`, `${formatHour(raw.y[0])} - ${formatHour(raw.y[1])}`];
                                            }
                                            const yRange = Array.isArray(raw) ? raw : (raw.y || null);
                                            if (yRange) {
                                                return `${formatHour(yRange[0])} - ${formatHour(yRange[1])}`;
                                            }
                                            return context.formattedValue;
                                        }
                                    }
                                }
                            }
                        },
                        plugins: [{
                            id: 'weekNav',
                            afterDatasetsDraw: (chart) => {
                                if (currentViewType !== 'month') return;
                                const { ctx, chartArea: { width }, scales: { x, y } } = chart;
                                const y7 = y.getPixelForValue(7);
                                const barHeight = 24;
                                const yPos = y7 - barHeight;
                                const daysInMonth = chart.data.labels.length;
                                const year = currentViewDate.getFullYear();
                                const month = currentViewDate.getMonth();
                                const weeks = [];
                                let curWeek = null;
                                let startI = 0;
                                for (let i = 0; i < daysInMonth; i++) {
                                    const d = new Date(year, month, i + 1);
                                    const w = getWeekNumber(d);
                                    if (curWeek === null) { curWeek = w; startI = i; }
                                    else if (w !== curWeek) {
                                        weeks.push({ w: curWeek, s: startI, e: i - 1 });
                                        curWeek = w; startI = i;
                                    }
                                }
                                weeks.push({ w: curWeek, s: startI, e: daysInMonth - 1 });
                                chart.weekZones = [];
                                const slotWidth = width / daysInMonth;
                                ctx.save();
                                ctx.font = 'bold 11px Inter';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                weeks.forEach(item => {
                                    const xStart = x.getPixelForValue(item.s) - slotWidth / 2 + 2;
                                    const xEnd = x.getPixelForValue(item.e) + slotWidth / 2 - 2;
                                    const w = xEnd - xStart;
                                    ctx.fillStyle = 'rgba(56, 189, 248, 0.25)';
                                    ctx.beginPath();
                                    ctx.rect(xStart, yPos, w, barHeight);
                                    ctx.fill();
                                    ctx.fillStyle = '#0ea5e9';
                                    ctx.fillText(`W${item.w}`, xStart + w / 2, yPos + barHeight / 2);
                                    chart.weekZones.push({
                                        x: xStart, y: yPos, w: w, h: barHeight,
                                        startDay: item.s + 1,
                                        week: item.w
                                    });
                                });
                                ctx.restore();
                            }
                        }]
                    });
                })
                .catch(err => {
                    console.error('Failed to init chart', err);
                    // Fallback to basic chart without tags if error?
                    // Just log it.
                });
        }



        function formatTableTimes() {
            document.querySelectorAll('.time-cell').forEach(cell => {
                const iso = cell.getAttribute('data-time');

                if (iso) {
                    const date = new Date(iso);
                    const h = date.getHours().toString().padStart(2, '0');
                    const m = date.getMinutes().toString().padStart(2, '0');
                    cell.innerText = `${h}:${m}`;
                } else {
                    cell.innerText = '-';
                }
            });
        }

        // Filter Modal Logic
        const modal = document.getElementById('filterModal');

        function openFilterModal() {
            modal.classList.add('active');
        }

        function closeFilterModal() {
            modal.classList.remove('active');
        }

        function resetFilters() {
            document.getElementById('filterText').value = '';
            document.getElementById('filterDateStart').value = '';
            document.getElementById('filterDateEnd').value = '';
            document.getElementById('filterTimeStartBefore').value = '';
            document.getElementById('filterTimeEndAfter').value = '';
            applyFilters();
        }

        function showTagTasksPopup(tag, tasks, event) {
            const popup = document.getElementById('tagTasksPopup');
            const title = document.getElementById('popupTagTitle');
            const list = document.getElementById('popupTasksList');

            if (!popup || !title || !list) return;

            title.innerHTML = `<span>${tag}</span> <span style="font-size: 0.7rem; color: var(--text-secondary); font-weight: normal;">${tasks.length} ${i18n['tasks']}</span>`;
            list.innerHTML = '';

            if (tasks && tasks.length > 0) {
                // De-duplicate tasks by description
                const uniqueTasksMap = new Map();
                tasks.forEach(t => {
                    if (!uniqueTasksMap.has(t.description) || t.is_completed) {
                        uniqueTasksMap.set(t.description, t);
                    }
                });
                const uniqueTasksList = Array.from(uniqueTasksMap.values());

                uniqueTasksList.slice(0, 10).forEach(t => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span class="task-status" style="color: ${t.is_completed ? 'var(--success)' : 'var(--danger)'}">${t.is_completed ? '‚úì' : '‚úó'}</span>
                        <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${t.description}</span>
                    `;
                    list.appendChild(li);
                });

                if (uniqueTasksList.length > 10) {
                    const li = document.createElement('li');
                    li.style.justifyContent = 'center';
                    li.style.color = 'var(--text-secondary)';
                    li.style.fontSize = '0.75rem';
                    li.style.marginTop = '0.25rem';
                    li.textContent = `+ ${uniqueTasksList.length - 10} more...`;
                    list.appendChild(li);
                }
            } else {
                const li = document.createElement('li');
                li.style.color = 'var(--text-secondary)';
                li.style.fontStyle = 'italic';
                li.textContent = 'No tasks';
                list.appendChild(li);
            }

            popup.style.display = 'block';
            popup.style.opacity = '1';
            updateTagTasksPopupPosition(event);
        }

        function updateTagTasksPopupPosition(event) {
            const popup = document.getElementById('tagTasksPopup');
            if (!popup || popup.style.display === 'none') return;

            const padding = 15;
            let x = event.pageX + padding;
            let y = event.pageY + padding;

            const popupRect = popup.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Check right edge
            if (x + popupRect.width > viewportWidth + window.scrollX) {
                x = event.pageX - popupRect.width - padding;
            }

            // Check bottom edge
            if (y + popupRect.height > viewportHeight + window.scrollY) {
                y = event.pageY - popupRect.height - padding;
            }

            popup.style.left = x + 'px';
            popup.style.top = y + 'px';
        }

        function hideTagTasksPopup() {
            const popup = document.getElementById('tagTasksPopup');
            if (popup) {
                popup.style.opacity = '0';
                setTimeout(() => {
                    if (popup.style.opacity === '0') popup.style.display = 'none';
                }, 200);
            }
        }

        // Detailed Popup Logic
        function showSessionDetails(session) {
            const popup = document.getElementById('detailPopup');
            const title = document.getElementById('detailTitle');
            const subtitle = document.getElementById('detailSubtitle');
            const stats = document.getElementById('detailStatsSummary');
            const tasksList = document.getElementById('detailTasksList');
            const link = document.getElementById('detailLink');

            const date = new Date(session.date);
            const dateStr = date.toLocaleDateString(currentLang, { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' });

            title.innerText = session.goal || i18n['working_day'];
            subtitle.innerText = dateStr;

            // Stats
            const startH = getLocalHour(session.start_time);
            const endH = getLocalHour(session.end_time);
            const pauseH = getTotalPauseHours(session.pauses);
            let workH = 0;
            if (startH && endH) {
                workH = Math.max(endH - startH - pauseH, 0);
            }

            stats.innerHTML = `
                <div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">${i18n['total_hours']}</div>
                    <div style="font-weight: 600;">${Math.floor(workH)}h ${Math.round((workH % 1) * 60)}m</div>
                </div>
                <div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">${i18n['status']}</div>
                    <div style="font-weight: 600; color: var(--accent);">${i18n[session.status] || session.status}</div>
                </div>
                <div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">${i18n['tasks']}</div>
                    <div style="font-weight: 600;">${session.tasks.filter(t => t.is_completed).length} / ${session.tasks.length}</div>
                </div>
            `;

            // Tasks
            renderDetailedTasks(session.tasks, tasksList);

            link.href = `/dashboard/${session.id}?edit=true`;
            link.innerText = i18n['open_dashboard'];
            link.style.display = 'inline-block';

            popup.classList.add('active');
        }

        function showSupertagDetails(group) {
            const popup = document.getElementById('detailPopup');
            const title = document.getElementById('detailTitle');
            const subtitle = document.getElementById('detailSubtitle');
            const stats = document.getElementById('detailStatsSummary');
            const tasksList = document.getElementById('detailTasksList');
            const link = document.getElementById('detailLink');

            title.innerText = group.name;
            title.style.color = group.color;

            // Subtags list
            const subtagsStr = group.subtags.map(st => st.tag).join(', ');
            subtitle.innerText = subtagsStr || 'No tags';

            const hours = Math.floor(group.timeMins / 60);
            const minutes = Math.round(group.timeMins % 60);

            stats.innerHTML = `
                <div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">${i18n['total_hours']}</div>
                    <div style="font-weight: 600;">${hours}h ${minutes}m</div>
                </div>
                <div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">${i18n['completion']}</div>
                    <div style="font-weight: 600; color: #fff;">${Math.round(group.completed / group.total * 100 || 0)}%</div>
                </div>
                <div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">${i18n['tasks']}</div>
                    <div style="font-weight: 600;">${Math.round(group.completed * 10) / 10} / ${Math.round(group.total * 10) / 10}</div>
                </div>
            `;

            const allTasks = [];
            group.subtags.forEach(st => {
                if (st.taskData && st.taskData.tasks) {
                    allTasks.push(...st.taskData.tasks);
                }
            });
            renderDetailedTasks(allTasks, tasksList);

            link.style.display = 'none';
            popup.classList.add('active');
        }

        function renderDetailedTasks(tasks, container) {
            container.innerHTML = '';
            if (!tasks || tasks.length === 0) {
                container.innerHTML = `<li style="color: var(--text-secondary); font-style: italic;">No tasks found</li>`;
                return;
            }

            // Group duplicates
            const taskMap = new Map();
            tasks.forEach(t => {
                const key = t.description;
                if (!taskMap.has(key)) {
                    taskMap.set(key, { ...t, count: 1 });
                } else {
                    taskMap.get(key).count++;
                    if (t.is_completed) taskMap.get(key).is_completed = true;
                }
            });

            Array.from(taskMap.values()).forEach(t => {
                const li = document.createElement('li');
                li.className = 'task-item-detailed';
                li.innerHTML = `
                    <div class="task-detail-status ${t.is_completed ? 'task-detail-completed' : 'task-detail-pending'}">
                        ${t.is_completed ? '‚úì' : '‚úó'}
                    </div>
                    <div style="flex: 1; min-width: 0;">
                        <div style="color: var(--text-primary); font-size: 0.95rem; line-height: 1.4;">${t.description}</div>
                        ${t.count > 1 ? `<div style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 2px;">Multiple occurrences (${t.count})</div>` : ''}
                    </div>
                `;
                container.appendChild(li);
            });
        }

        function closeDetailPopup() {
            const popup = document.getElementById('detailPopup');
            if (popup) popup.classList.remove('active');
        }

        // Close on escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeDetailPopup();
        });

        // Close on click outside card
        document.getElementById('detailPopup').addEventListener('click', (e) => {
            if (e.target.id === 'detailPopup') closeDetailPopup();
        });

        function applyFilters() {
            const textTerm = document.getElementById('filterText').value.toLowerCase();
            const dateStart = document.getElementById('filterDateStart').value; // YYYY-MM-DD
            const dateEnd = document.getElementById('filterDateEnd').value;     // YYYY-MM-DD
            const startTimeBefore = normalizeTimeInput(document.getElementById('filterTimeStartBefore').value); // HH:MM
            const endTimeAfter = normalizeTimeInput(document.getElementById('filterTimeEndAfter').value);     // HH:MM

            const rows = document.querySelectorAll('.metrics-table tbody tr');

            rows.forEach(row => {
                // Skip "No sessions" row
                if (row.cells.length < 2) return;

                let show = true;

                // 1. Text Search
                if (textTerm) {
                    let textMatch = false;
                    // Check text content
                    if (row.innerText.toLowerCase().includes(textTerm)) textMatch = true;
                    // Check inputs
                    const inputs = row.querySelectorAll('input');
                    inputs.forEach(input => {
                        if (input.value.toLowerCase().includes(textTerm)) textMatch = true;
                    });
                    if (!textMatch) show = false;
                }

                // Get row data
                // Date is cell 0 (text content) or better from data attribute of Start/End cells
                const dateCell = row.querySelector('[data-date]');
                const rowDate = dateCell ? dateCell.getAttribute('data-date') : null; // YYYY-MM-DD

                // 2. Date Range
                if (show && rowDate) {
                    if (dateStart && rowDate < dateStart) show = false;
                    if (dateEnd && rowDate > dateEnd) show = false;
                }

                // 3. Time Logic
                // Start time cell input value
                const startInput = row.querySelector('td[data-type="start"] input');
                const endInput = row.querySelector('td[data-type="end"] input');
                const rowStart = startInput ? startInput.value : ''; // HH:MM
                const rowEnd = endInput ? endInput.value : '';     // HH:MM

                if (show && startTimeBefore && rowStart) {
                    if (rowStart >= startTimeBefore) show = false;
                }

                if (show && endTimeAfter && rowEnd) {
                    if (rowEnd <= endTimeAfter) show = false;
                }

                row.style.display = show ? '' : 'none';
            });

            closeFilterModal();
        }

        function normalizeTimeInput(value) {
            if (!value) return null;
            const trimmed = value.trim();
            const match = trimmed.match(/^([01]?\d|2[0-3]):([0-5]\d)$/);
            if (!match) return null;
            const h = match[1].padStart(2, '0');
            const m = match[2];
            return `${h}:${m}`;
        }

        function applyTimeMask(input) {
            input.addEventListener('input', function (e) {
                let val = e.target.value.replace(/\D/g, '');
                if (val.length > 4) val = val.slice(0, 4);

                if (val.length >= 2) {
                    let h = val.slice(0, 2);
                    if (parseInt(h) > 23) h = "23";
                    let m = val.slice(2);
                    if (m.length >= 2) {
                        if (parseInt(m) > 59) m = "59";
                        val = h + ":" + m.slice(0, 2);
                    } else if (val.length > 2) {
                        val = h + ":" + m;
                    } else {
                        val = h + ":";
                    }
                }
                e.target.value = val;
            });

            input.addEventListener('keydown', function (e) {
                if (e.key === 'Backspace' && e.target.value.endsWith(':')) {
                    e.preventDefault();
                    e.target.value = e.target.value.slice(0, -2);
                }
            });
        }

        applyTimeMask(document.getElementById('filterTimeStartBefore'));
        applyTimeMask(document.getElementById('filterTimeEndAfter'));

        // Close modal on outside click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) closeFilterModal();
        });

        formatTableTimes();
        initMetrics();
    </script>
    <script src="{{ url_for('static', filename='script.js') }}"></script>
</body>

</html>